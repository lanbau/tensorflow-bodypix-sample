import { useRef, useState, useEffect } from "react";
import Head from "next/head";
import "@tensorflow/tfjs-core";
import "@tensorflow/tfjs-converter";
import "@tensorflow/tfjs-backend-webgl";
import styles from "../styles/Home.module.scss";
import * as bodyPix from "@tensorflow-models/body-pix";
import Webcam from "react-webcam";
import { useRouter } from "next/dist/client/router";
import en from "../locales/en";
import ja from "../locales/ja";
import { WebcamCapture } from "../components/Webcam";

async function removebackground() {
  const canvas = document.querySelector("canvas");
  const ctx = canvas.getContext("2d");

  // Loading the model
  const net = await bodyPix.load({
    architecture: "MobileNetV1",
    outputStride: 16,
    multiplier: 0.75,
    quantBytes: 2,
  });

  // Segmentation
  const { data: map } = await net.segmentPerson(canvas, {
    internalResolution: "medium",
  });

  // Extracting image data
  const { data: imgData } = ctx.getImageData(0, 0, canvas.width, canvas.height);

  // Creating new image data
  const newImg = ctx.createImageData(canvas.width, canvas.height);
  const newImgData = newImg.data;

  for (let i = 0; i < map.length; i++) {
    //The data array stores four values for each pixel
    const [r, g, b, a] = [
      imgData[i * 4],
      imgData[i * 4 + 1],
      imgData[i * 4 + 2],
      imgData[i * 4 + 3],
    ];
    [
      newImgData[i * 4],
      newImgData[i * 4 + 1],
      newImgData[i * 4 + 2],
      newImgData[i * 4 + 3],
    ] = !map[i] ? [255, 255, 255, 0] : [r, g, b, a];
  }

  // Draw the new image back to canvas
  ctx.putImageData(newImg, 0, 0);
}

function Home() {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const webcamRef = useRef<Webcam>(null);
  const [image,setImage]=useState('');
  
  const [bodypixnet, setBodypixnet] = useState<bodyPix.BodyPix>();
  const [prevClassName, setPrevClassName] = useState<string>();
  const { locale } = useRouter();
  const t = locale === "en" ? en : ja;
  const imgEl = useRef(null);
  const [loaded, setLoaded] = useState(false);

  const onImageLoaded = () => {
    removebackground();
    setLoaded(true);
  };
  useEffect(() => {
    bodyPix.load().then((net: bodyPix.BodyPix) => {
      setBodypixnet(net);
    });
  }, []);

  const drawimage = async (
    webcam: HTMLVideoElement,
    context: CanvasRenderingContext2D,
    canvas: HTMLCanvasElement
  ) => {
    // create tempCanvas
    const tempCanvas = document.createElement("canvas");
    tempCanvas.width = webcam.videoWidth;
    tempCanvas.height = webcam.videoHeight;
    const tempCtx = tempCanvas.getContext("2d");
    (async function drawMask() {
      requestAnimationFrame(drawMask);
      // draw mask on tempCanvas
      const segmentation = await bodypixnet.segmentPerson(webcam);
      const mask = bodyPix.toMask(segmentation);
      tempCtx.putImageData(mask, 0, 0);
      // draw original image
      context.drawImage(webcam, 0, 0, canvas.width, canvas.height);
      // use destination-out, then only masked area will be removed
      context.save();
      context.globalCompositeOperation = "destination-out";
      context.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);
      context.restore();
    })();
  };

  const clickHandler = async (className: string) => {
    const webcam = webcamRef.current.video as HTMLVideoElement;
    const canvas = canvasRef.current;
    webcam.width = canvas.width = webcam.videoWidth;
    webcam.height = canvas.height = webcam.videoHeight;
    const context = canvas.getContext("2d");
    context.clearRect(0, 0, canvas.width, canvas.height);
    if (prevClassName) {
      canvas.classList.remove(prevClassName);
      setPrevClassName(className);
    } else {
      setPrevClassName(className);
    }
    canvas.classList.add(className);
    if (bodypixnet) {
      drawimage(webcam, context, canvas);
    }
  };

  useEffect(() => {
    const img = new Image();
    img.crossOrigin = "";
    const canvas = document.querySelector("canvas");
    const ctx = canvas.getContext("2d");
    // img.src = "images/Irvin-lin.jpeg";
    img.src = image

    const imgElCurrent = imgEl.current;
    // console.log('img', img)

    if (img) {
      img.addEventListener("load", () => {
        // Set canvas width, height same as image
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);
        removebackground();
      });
      return () => img.removeEventListener("load", onImageLoaded);
    }
  }, [image]);
  return (
    <div className={styles.container}>
       <canvas></canvas>
       <WebcamCapture image={image} setImage={setImage}/>
      {/* <Head>
        <title>Travel App</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/static/logo.jpg" />
      </Head>
      <header className={styles.header}>
        <h1 className={styles.title}>{t.title}</h1>
      </header> */}
      <main className={styles.main}>
     
        {/* <div className={styles.videoContainer}>
          <Webcam audio={false} ref={webcamRef} className={styles.video} />
          <canvas ref={canvasRef} className={styles.canvas} />
        </div> */}
        {/* <div className={styles.right}>
          <h4 className={styles.title}>{t.select}</h4>
          <div className={styles.buttons}>
            <button onClick={() => clickHandler(styles.argentina)}>
             Test
            </button>
            <button onClick={() => clickHandler(styles.argentina)}>
              {t.argentina}
            </button>
            <button onClick={() => clickHandler(styles.austria)}>
              {t.austria}
            </button>
            <button onClick={() => clickHandler(styles.brazil)}>
              {t.brazil}
            </button>
            <button onClick={() => clickHandler(styles.bulgaria)}>
              {t.bulgaria}
            </button>
            <button onClick={() => clickHandler(styles.cambodia)}>
              {t.cambodia}
            </button>
            <button onClick={() => clickHandler(styles.dubai)}>
              {t.dubai}
            </button>
            <button onClick={() => clickHandler(styles.egypt)}>
              {t.egypt}
            </button>
            <button onClick={() => clickHandler(styles.germany)}>
              {t.germany}
            </button>
            <button onClick={() => clickHandler(styles.india)}>
              {t.india}
            </button>
            <button onClick={() => clickHandler(styles.korea)}>
              {t.korea}
            </button>
            <button onClick={() => clickHandler(styles.romania)}>
              {t.romania}
            </button>
            <button onClick={() => clickHandler(styles.slovakia)}>
              {t.slovakia}
            </button>
            <button onClick={() => clickHandler(styles.spain)}>
              {t.spain}
            </button>
            <button onClick={() => clickHandler(styles.tailand)}>
              {t.tailand}
            </button>
            <button onClick={() => clickHandler(styles.taiwan)}>
              {t.taiwan}
            </button>
            <button onClick={() => clickHandler(styles.turky)}>
              {t.turky}
            </button>
          </div>
        </div> */}
      </main>
    </div>
  );
}

export default Home;
